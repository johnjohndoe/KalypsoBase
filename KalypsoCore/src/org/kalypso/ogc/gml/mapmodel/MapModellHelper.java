/*----------------    FILE HEADER KALYPSO ------------------------------------------
 *
 *  This file is part of kalypso.
 *  Copyright (C) 2004 by:
 *
 *  Technical University Hamburg-Harburg (TUHH)
 *  Institute of River and coastal engineering
 *  Denickestraﬂe 22
 *  21073 Hamburg, Germany
 *  http://www.tuhh.de/wb
 *
 *  and
 *
 *  Bjoernsen Consulting Engineers (BCE)
 *  Maria Trost 3
 *  56070 Koblenz, Germany
 *  http://www.bjoernsen.de
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *  Contact:
 *
 *  E-Mail:
 *  belger@bjoernsen.de
 *  schlienger@bjoernsen.de
 *  v.doemming@tuhh.de
 *
 *  ---------------------------------------------------------------------------*/
package org.kalypso.ogc.gml.mapmodel;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Insets;
import java.awt.Polygon;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;

import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.jface.dialogs.ErrorDialog;
import org.eclipse.swt.widgets.Shell;
import org.kalypso.contribs.eclipse.jface.operation.ICoreRunnableWithProgress;
import org.kalypso.contribs.eclipse.ui.progress.ProgressUtilities;
import org.kalypso.core.i18n.Messages;
import org.kalypso.ogc.gml.IKalypsoTheme;
import org.kalypso.ogc.gml.IKalypsoThemeFilter;
import org.kalypso.ogc.gml.map.IMapPanel;
import org.kalypso.ogc.gml.mapmodel.visitor.KalypsoThemeLoadStatusVisitor;
import org.kalypso.ogc.gml.mapmodel.visitor.KalypsoThemeVisitor;
import org.kalypsodeegree.graphics.transformation.GeoTransform;
import org.kalypsodeegree.model.feature.FeatureVisitor;
import org.kalypsodeegree.model.geometry.GM_Envelope;
import org.kalypsodeegree_impl.graphics.transformation.WorldToScreenTransform;
import org.kalypsodeegree_impl.model.geometry.GeometryFactory;

/**
 * Utility class for {@link IMapModell} associated functions.
 *
 * @author Gernot Belger
 */
public final class MapModellHelper
{
  private MapModellHelper( )
  {
    throw new UnsupportedOperationException( Messages.getString( "org.kalypso.ogc.gml.mapmodel.MapModellHelper.0" ) ); //$NON-NLS-1$
  }

  /**
   * Waits for a {@link MapPanel} to be completely loaded. A progress dialog opens if this operation takes long.<br>
   * If an error occurs, an error dialog will be shown.
   *
   * @param panelOrModell
   *          An {@link IMapPanel} or an {@link IMapModell}. Use a panel, if the modell is stil about to be loaded. Use
   *          a modell, if you do not have a panel (i.e. for image export or similar).
   * @return <code>false</code> if any error happened, the map is not guaranteed to be loaded in this case.
   * @see ProgressUtilities#busyCursorWhile(ICoreRunnableWithProgress)
   * @see #createWaitForMapOperation(MapPanel)
   */
  // FIXME: we need to use default texts here. The same text is i10n a 1000 times now... :-(
  public static boolean waitForAndErrorDialog( final Shell shell, final Object panelOrModell, final String windowTitle, final String message )
  {
    final ICoreRunnableWithProgress operation = createWaitForMapOperation( panelOrModell );
    final IStatus waitErrorStatus = ProgressUtilities.busyCursorWhile( operation );
    ErrorDialog.openError( shell, windowTitle, message, waitErrorStatus );
    return waitErrorStatus.isOK();
  }

  /**
   * Creates an {@link ICoreRunnableWithProgress} which waits for a {@link MapPanel} to be loaded.<br>
   * Uses the {@link IMapModell#isLoaded()} and {@link IKalypsoTheme#isLoaded()} methods.
   *
   * @param panelOrModell
   *          An {@link IMapPanel} or an {@link IMapModell}. Use a panel, if the modell is stil about to be loaded. Use
   *          a modell, if you do not have a panel (i.e. for image export or similar).
   */
  public static ICoreRunnableWithProgress createWaitForMapOperation( final Object panelOrModell )
  {
    return new WaitForMapOperation( panelOrModell );
  }

  /**
   * This function creates an image of a map model and keeps aspect ratio of the displayed map and its extend.
   *
   * @param panel
   *          The map panel.
   * @param width
   *          The width of the new image.
   * @param height
   *          The height of the new image.
   * @param insets
   *          The insets of the image define a print border, which is kept empty.
   * @param borderWidth
   *          If >0 and <=25 a border will be drawn around the map.
   * @return The image showing the map.
   */
  public static BufferedImage createWellFormedImageFromModel( final IMapPanel panel, final int width, final int height, final Insets insets, final int borderWidth )
  {
    /* Get the map model. */
    final IMapModell mapModel = panel.getMapModell();

    /* Get the bounding box. */
    final GM_Envelope boundingBox = panel.getBoundingBox();

    return createWellFormedImageFromModel( mapModel, width, height, insets, borderWidth, boundingBox );
  }

  /**
   * This function creates an image of a map model and keeps aspect ratio of the displayed map and its extend.
   *
   * @param mapModel
   *          The map model.
   * @param width
   *          The width of the new image.
   * @param height
   *          The height of the new image.
   * @param insets
   *          The insets of the image define a print border, which is kept empty.
   * @param borderWidth
   *          If >0 and <=25 a border will be drawn around the map.
   * @param boundingBox
   *          The original bounding box.
   * @return The image showing the map.
   */
  public static BufferedImage createWellFormedImageFromModel( final IMapModell mapModel, final int width, final int height, final Insets insets, final int borderWidth, final GM_Envelope boundingBox )
  {
    /* The remaining dimensions for the map considering the insets. */
    int mapWidth = width;
    int mapHeight = height;
    if( insets != null )
    {
      /* Calculate the remaining dimensions. */
      mapWidth = mapWidth - insets.left - insets.right;
      mapHeight = mapHeight - insets.top - insets.bottom;
    }

    /* The remaining dimensions for the map considering the width of the border. */
    if( borderWidth > 0 && borderWidth <= 25 )
    {
      /* Calculate the remaining dimensions. */
      mapWidth = mapWidth - borderWidth;
      mapHeight = mapHeight - borderWidth;
    }

    /* Calculate the ratio of the width and height of the available to the map. */
    final double ratio = (double) mapHeight / (double) mapWidth;

    /* Adjust the bounding box. */
    final GM_Envelope adjustedBoundingBox = MapModellHelper.adjustBoundingBox( mapModel, boundingBox, ratio );

    return MapModellHelper.createImageFromModell( mapModel, width, height, insets, borderWidth, adjustedBoundingBox );
  }

  /**
   * This function is used to create an image of a map model. It does not wait until all themes are loaded. It is used
   * from the map panel as well, where the drawing is done every refresh of the map. So it does not matter, when some
   * themes finish, if they finish at all.
   *
   * @param panel
   *          The map panel.
   * @param width
   *          The width of the new image.
   * @param height
   *          The height of the new image.
   * @param insets
   *          The insets of the image define a print border, which is kept empty.
   * @param borderWidth
   *          If >0 and <=25 a border will be drawn around the map.
   * @param boundingBox
   *          The envelope of the map, which should be exported.
   * @return The image showing the map.
   */
  public static BufferedImage createImageFromModell( final IMapModell model, final int width, final int height, Insets insets, int borderWidth, final GM_Envelope boundingBox )
  {
    /* If there is no bounding box, we cannot draw the map. */
    if( boundingBox == null )
      return new BufferedImage( width, height, BufferedImage.TYPE_INT_ARGB );

    /* If the insets are missing, create them with the width of all borders = 0. */
    if( insets == null )
      insets = new Insets( 0, 0, 0, 0 );

    /* Make sure, the width of the border lies within the allowed bounds. */
    if( borderWidth <= 0 || borderWidth > 25 )
      borderWidth = 0;

    /* Calculate the remaining dimensions for the map considering the insets and the border. */
    final int mapWidth = width - insets.left - insets.right - borderWidth;
    final int mapHeight = height - insets.top - insets.bottom - borderWidth;

    /* Create the image for the map WITH the insets AND the border. */
    final BufferedImage image = new BufferedImage( width, height, BufferedImage.TYPE_INT_ARGB );
    final Graphics2D gr = (Graphics2D) image.getGraphics();

    /* Create the image for the map WITHOUT the insets AND the border. */
    final BufferedImage mapImage = new BufferedImage( mapWidth, mapHeight, BufferedImage.TYPE_INT_ARGB );
    final Graphics2D mapgr = (Graphics2D) mapImage.getGraphics();

    try
    {
      /* Make the backgrounds completely white. */
      gr.setColor( Color.white );
      gr.fillRect( 0, 0, width, height );
      mapgr.setColor( Color.white );
      mapgr.fillRect( 0, 0, mapWidth, mapHeight );

      /* Set the clips. */
      gr.setColor( Color.black );
      gr.setClip( 0, 0, width, height );
      mapgr.setColor( Color.black );
      mapgr.setClip( 0, 0, mapWidth, mapHeight );

      /* Configure the graphics contexts. */
      gr.setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON );
      gr.setRenderingHint( RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON );
      mapgr.setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON );
      mapgr.setRenderingHint( RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON );

      /* Create the world to screen transform. */
      final GeoTransform world2screen = new WorldToScreenTransform();
      world2screen.setSourceRect( boundingBox );
      world2screen.setDestRect( 0, 0, mapWidth, mapHeight, null );

      /* Paint the map. */
      model.paint( mapgr, world2screen, new NullProgressMonitor() );

      /* Draw it onto the image. */
      gr.drawImage( mapImage, insets.left + borderWidth, insets.top + borderWidth, null );

      /* Draw the border. */
      /* The insets and the space for the border are already considered on the image. */
      final Polygon polygon = new Polygon();
      polygon.addPoint( insets.left, insets.top );
      polygon.addPoint( insets.left + borderWidth + mapWidth + borderWidth, insets.top );
      polygon.addPoint( insets.left + borderWidth + mapWidth + borderWidth, insets.top + borderWidth + mapHeight + borderWidth );
      polygon.addPoint( insets.left, insets.top + borderWidth + mapHeight + borderWidth );
      polygon.addPoint( insets.left, insets.top );
      polygon.addPoint( insets.left + borderWidth, insets.top + borderWidth );
      polygon.addPoint( insets.left + borderWidth + mapWidth, insets.top + borderWidth );
      polygon.addPoint( insets.left + borderWidth + mapWidth, insets.top + borderWidth + mapHeight );
      polygon.addPoint( insets.left + borderWidth, insets.top + borderWidth + mapHeight );
      polygon.addPoint( insets.left + borderWidth, insets.top + borderWidth );
      gr.fill( polygon );
    }
    catch( final Exception ex )
    {
      /* Print the stack trace. */
      ex.printStackTrace();
    }
    finally
    {
      /* Dispose the graphics contexts. */
      gr.dispose();
      mapgr.dispose();
    }

    return image;
  }

  public static IKalypsoTheme[] filterThemes( final IMapModell modell, final IKalypsoThemeFilter filter )
  {
    final IKalypsoTheme[] allThemes = modell.getAllThemes();
    final List<IKalypsoTheme> themes = new ArrayList<>( allThemes.length );
    for( final IKalypsoTheme theme : allThemes )
      if( filter.accept( theme ) )
        themes.add( theme );

    return themes.toArray( new IKalypsoTheme[themes.size()] );
  }

  /**
   * Calculates the common extent of all given themes.
   *
   * @param predicate
   *          If not <code>null</code>, only themes applying to the predicate are considered.
   * @return <code>null</code>, if the array of themes is empty or null.
   */
  public static GM_Envelope calculateExtent( final IKalypsoTheme[] themes, final IKalypsoThemePredicate predicate )
  {
    if( themes == null )
      return null;

    GM_Envelope result = null;
    for( final IKalypsoTheme kalypsoTheme : themes )
    {
      if( predicate == null || predicate.decide( kalypsoTheme ) )
      {
        final GM_Envelope boundingBox = kalypsoTheme.getFullExtent();
        if( result == null )
          result = boundingBox;
        else
          result = result.getMerged( boundingBox );
      }
    }

    return result;
  }

  /**
   * Adjust an given bounding box (env) to an new ratio
   */
  public static GM_Envelope adjustBoundingBox( final IMapModell model, GM_Envelope env, final double ratio )
  {
    if( env == null )
      env = model == null ? null : model.getFullExtentBoundingBox();

    if( env == null )
      return null;

    if( Double.isNaN( ratio ) )
      return env;

    final double minX = env.getMin().getX();
    final double minY = env.getMin().getY();

    final double maxX = env.getMax().getX();
    final double maxY = env.getMax().getY();

    double dx = (maxX - minX) / 2d;
    double dy = (maxY - minY) / 2d;

    if( dx * ratio > dy )
      dy = dx * ratio;
    else
      dx = dy / ratio;

    final double mx = (maxX + minX) / 2d;
    final double my = (maxY + minY) / 2d;

    return GeometryFactory.createGM_Envelope( mx - dx, my - dy, mx + dx, my + dy, env.getCoordinateSystem() );
  }

  /**
   * Tests if a given map-model is fully loaded.<br>
   * REMARK: this only checks, that all its themes (and sub-themes) return <code>true</code> for its isLoaded methods<br>
   * Themes may also report <code>true</code>, if loading its data has failed.
   */
  public static boolean isMapLoaded( final IMapModell model )
  {
    if( model == null || !model.isLoaded() )
      return false;

    final KalypsoThemeLoadStatusVisitor visitor = new KalypsoThemeLoadStatusVisitor();
    model.accept( visitor, FeatureVisitor.DEPTH_INFINITE );

    return visitor.isLoaded();
  }

  /**
   * Finds all themes with the given theme property from the map model.
   *
   * @param mapModel
   *          This model is searched
   * @param themeProperty
   *          This where this property is set are found
   * @param depth
   *          One of the {@link IKalypsoThemeVisitor#DEPTH_} constants.
   */
  public static IKalypsoTheme[] findThemeByProperty( final IMapModell mapModel, final String themeProperty, final int depth )
  {
    final IKalypsoThemePredicate predicate = new IKalypsoThemePredicate()
    {
      @Override
      public boolean decide( final IKalypsoTheme theme )
      {
        final String property = theme.getProperty( themeProperty, null );
        return property != null;
      }
    };

    final KalypsoThemeVisitor visitor = new KalypsoThemeVisitor( predicate );
    mapModel.accept( visitor, depth );
    return visitor.getFoundThemes();
  }
}